%# BEGIN BPS TAGGED BLOCK {{{
%# 
%# COPYRIGHT:
%#  
%# This software is Copyright (c) 1996-2007 Best Practical Solutions, LLC 
%#                                          <jesse@bestpractical.com>
%# 
%# (Except where explicitly superseded by other copyright notices)
%# 
%# 
%# LICENSE:
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/copyleft/gpl.html.
%# 
%# 
%# CONTRIBUTION SUBMISSION POLICY:
%# 
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%# 
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%# 
%# END BPS TAGGED BLOCK }}}
<%ARGS>
$Format => RT->config->get('DefaultSearchResultFormat')

%cfqueues => ()

$Face => undef
$Size => undef
$Link => undef
$Title => undef

$AddCol => undef
$RemoveCol => undef
$ColUp => undef
$ColDown => undef

$SelectDisplayColumns => undef
$CurrentDisplayColumns => undef
</%ARGS>
<%ONCE>

# All the things we can display in the format string by default
my @fields = qw(
    id Queuename subject
    Status ExtendedStatus UpdateStatus
    Type

    Ownername Requestors Cc AdminCc CreatedBy LastUpdatedBy

    Priority initial_priority final_priority

    time_worked time_left time_estimated

    starts      startsRelative
    Started     StartedRelative
    Created     CreatedRelative
    LastUpdated LastUpdatedRelative
    Told        ToldRelative
    Due         DueRelative
    Resolved    ResolvedRelative

    RefersTo    ReferredToBy
    DependsOn   DependedOnBy
    MemberOf    Members
    Parents     Children

    NEWLINE
);

</%ONCE>
<%init>
$m->callback( CallbackOnce => 1, Callbackname => 'SetFieldsOnce', Fields => \@fields );

my $CustomFields = RT::Model::CustomFieldCollection->new();
foreach my $id (keys %cfqueues) {
    # Gotta load up the $queue object, since queues get stored by name now. my $id
    my $queue = RT::Model::Queue->new();
    $queue->load($id);
    unless ($queue->id) {
        # XXX TODO: This ancient code dates from a former developer
        # we have no idea what it means or why cfqueues are so encoded.
        $id =~ s/^.'*(.*).'*$/$1/;
        $queue->load($id);
    }
    $queue->load($id);
    $CustomFields->limit_to_queue($queue->id);
}
$CustomFields->limit_to_global;

while ( my $CustomField = $CustomFields->next ) {
    push @fields, "CustomField.{" . $CustomField->name . "}";
}

$m->callback( Fields => \@fields, ARGSRef => \%ARGS );

my ( @seen);

$Format ||= RT->config->get('DefaultSearchResultFormat');
my @format = split( /,\s*/, $Format );
foreach my $field (@format) {
    my %column = ();
    $field =~ s/'(.*)'/$1/;
    my ( $prefix, $suffix );
    if ( $field =~ m/(.*)__(.*)__(.*)/ ) {
        $prefix = $1;
        $suffix = $3;
        $field  = $2;
    }
    $field = "<blank>" if !$field;
    $column{Prefix} = $prefix;
    $column{Suffix} = $suffix;
    $field =~ s/\s*(.*)\s*/$1/;
    $column{Column} = $field;
    push @seen, \%column;
}

if ( $RemoveCol ) {
    my $index  = $CurrentDisplayColumns;
    my $column = $seen[$index];
    if ($index) {
        delete $seen[$index];
        my @temp = @seen;
        @seen = ();
        foreach my $element (@temp) {
            next unless $element;
            push @seen, $element;
        }
    }
}
elsif ( $AddCol ) {
    if ( defined $SelectDisplayColumns ) {
        my $selected = $SelectDisplayColumns;
        my @columns;
        if (ref($selected) eq 'ARRAY') {
            @columns = @$selected;
        } else {
            push @columns, $selected;
        }
        foreach my $col (@columns) {
            my %column = ();
            $column{Column} = $col;

            if ( $Face eq "Bold" ) {
                $column{Prefix} .= "<b>";
                $column{Suffix} .= "</b>";
            }
            if ( $Face eq "Italic" ) {
                $column{Prefix} .= "<i>";
                $column{Suffix} .= "</i>";
            }
            if ($Size) {
                $column{Prefix} .= "<" . $m->interp->apply_escapes( $Size,  'h' ) . ">";
                $column{Suffix} .= "</" . $m->interp->apply_escapes( $Size, 'h' ) . ">";
            }
            if ( $Link eq "Display" ) {
                $column{Prefix} .= q{<a HREF="__WebPath__/Ticket/Display.html?id=__id__">};
                $column{Suffix} .= "</a>";
            }
            elsif ( $Link eq "Take" ) {
                $column{Prefix} .= q{<a HREF="__WebPath__/Ticket/Display.html?Action=Take&id=__id__">};
                $column{Suffix} .= "</a>";
            }

            if ($Title) {
                $column{Suffix} .= "/TITLE:" . $m->interp->apply_escapes( $Title, 'h' );
            }
            push @seen, \%column;
        }
    }
}
elsif ( $ColUp ) {
    my $index = $CurrentDisplayColumns;
    if ( defined $index && ( $index - 1 ) >= 0 ) {
        my $column = $seen[$index];
        $seen[$index]       = $seen[ $index - 1 ];
        $seen[ $index - 1 ] = $column;
        $CurrentDisplayColumns     = $index - 1;
    }
}
elsif ( $ColDown ) {
    my $index = $CurrentDisplayColumns;
    if ( defined $index && ( $index + 1 ) < scalar @seen ) {
        my $column = $seen[$index];
        $seen[$index]       = $seen[ $index + 1 ];
        $seen[ $index + 1 ] = $column;
        $CurrentDisplayColumns     = $index + 1;
    }
}


my @format_string;
foreach my $field (@seen) {
    next unless $field;
    my $row = "'";
    $row .= $field->{'Prefix'} if defined $field->{'Prefix'};
    $row .= "__" . ($field->{'Column'} =~ m/\(/ ? $field->{'Column'} # func, don't escape
		    : $m->interp->apply_escapes( $field->{'Column'}, 'h' )) . "__"
      unless ( $field->{'Column'} eq "<blank>" );
    $row .= $field->{'Suffix'} if defined $field->{'Suffix'};
    $row .= "'";
    push( @format_string, $row );
}

$Format = join(",\n", @format_string);


return($Format, \@fields, \@seen);

</%init>
