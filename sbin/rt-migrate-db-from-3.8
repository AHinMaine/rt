#!/usr/bin/perl 

use strict;
use warnings;

use Getopt::Long;
use Carp;
use Text::Naming::Convention qw/renaming/;

use FindBin;
use lib "$FindBin::Bin/../lib";

my %opts;
GetOptions( \%opts,
    "help", "upgrade", "debug",
);
if ( $opts{'help'} || !$opts{'upgrade'} ) {
    require Pod::Usage;
    import Pod::Usage;
    pod2usage(-verbose => 1);
    exit 1;
}

{
    require Jifty::Script::Schema;
    my $schema = Jifty::Script::Schema->new(
        no_bootstrap      => 1,
        no_model_tables   => 1,
        create_database   => 0,
        drop_database     => 0,
    );
    $schema->setup_environment;
    Jifty->setup_database_connection( no_version_check => 1 );
    $schema->create_all_tables;
}


{
    require Jifty::Everything;
    import Jifty::Everything;
    new Jifty;
}



my $db_name_rt3 = $opts{'db-name-rt3'} || 'rt3';
my $db_type = Jifty->config->framework('Database')->{'Driver'};
my $db_name_rt4 = Jifty->config->framework('Database')->{'Database'};
my $db_user = Jifty->config->framework('Database')->{'User'};
my $dbh = Jifty->handle->dbh;

my %name_changes = (
    nick_name           => 'nickname',
    email_address       => 'email',
    principal_type      => 'type',
    immediate_parent_id => 'immediate_parent',
);

my @tables = qw/ACL Attachments  Attributes CachedGroupMembers CustomFieldValues
CustomFields GroupMembers Groups Links ObjectCustomFieldValues ObjectCustomFields
Principals  Queues ScripActions ScripConditions Scrips Templates Tickets
Transactions Users sessions/;

sub update_acl_table {
# delete delegated rights
    execute_query("DELETE FROM ACL WHERE DelegatedBy != 0 AND DelegatedBy IS NOT NULL");
# drop columns related to delegations
    drop_columns(qw(ACL DelegatedBy DelegatedFrom) );
# replace PrincipalType with NULLs where it's not a role
    execute_query("UPDATE TABLE ACL SET PrincipalType = NULL WHERE PrincipalType IN ('User', 'Group')");
}

sub update_groups_table {
# delete personal groups, everything else can be covered by validator
    execute("DELETE FROM Groups WHERE Domain = 'Personal'");
}

sub update_principals_table {
    rename_columns('Principals', PrincipalType => 'Type');
    drop_columns(qw(Principals ObjectId));
}

# drop deprecated columns
drop_columns(@$_) foreach (
    [qw(Templates Language TranslationOf)],
    [qw(Scrips ConditionRules ActionRules)],
);

print "updating table Attributes\n";
# need to add a row for the default status schema in Attributes and update
# part columns of that table
require RT::Model::AttributeCollection;
my $collection =
  RT::Model::AttributeCollection->new( current_user => RT->system_user );
$collection->unlimit;
while ( my $attr = $collection->next ) {
    my $desc = $attr->description;
    $desc =~ s/\[_(\d)\]/%$1/g; # [_1] => %1
    $attr->set_description($desc);

    my $content = $attr->content;

    next unless ref $content && ref $content eq 'HASH';
    for my $k ( keys %$content ) {
        my $v = $content->{$k};
        delete $content->{$k};
        $content->{ renaming $k} = $v;
    }
    my $format = $content->{'format'};
    if ( $format ) {
        # update for the name convention changes
        $format =~ s/__(?!WebPath)(\w+)__/'__' . renaming($1) . '__'/eg;
        $format =~ s/TITLE:Subject/TITLE:subject/g;
        $format =~ s/(,\s*|^\s*)(\w+)(?=\s*,|\s*$)/$1 . renaming($2)/eg;
        $content->{'format'} = $format;
    }
    $attr->set_content($content);
}

# add default status schema
require RT::Model::Attribute;
my $attribute = RT::Model::Attribute->new( current_user => RT->system_user );
my @results = $attribute->create(
    name        => 'StatusSchemas',
    object      => RT->system,
    description => 'all system status schemas',
    content     => {
        default => {
            initial     => ['new'],
            active      => [ 'open', 'stalled' ],
            inactive    => [ 'resolved', 'rejected', 'deleted' ],
            transitions => {
                new      => [qw(open resolved rejected deleted)],
                open     => [qw(stalled resolved rejected deleted)],
                stalled  => [qw(open)],
                resolved => [qw(open)],
                rejected => [qw(open)],
                deleted  => [qw(open)],
            },
            actions => {
                'new -> open'     => [ 'Open It', 'respond' ],
                'new -> resolved' => [ 'Resolve', 'comment' ],
                'new -> rejected' => [ 'Reject',  'respond' ],
                'new -> deleted'  => [ 'Delete',  '' ],

                'open -> stalled'  => [ 'Stall',   'comment' ],
                'open -> resolved' => [ 'Resolve', 'comment' ],
                'open -> rejected' => [ 'Reject',  'respond' ],
                'open -> deleted'  => [ 'Delete',  'hide' ],

                'stalled -> open'  => [ 'Open It',  '' ],
                'resolved -> open' => [ 'Re-open',  'comment' ],
                'rejected -> open' => [ 'Re-open',  'comment' ],
                'deleted -> open'  => [ 'Undelete', '' ],
            },
        }
    }
);

print "updated attributes with success\n";


print "updating table Users\n";
require RT::Model::UserCollection;
my $user_collection =
  RT::Model::UserCollection->new( current_user => RT->system_user );

while ( my $user = $user_collection->next ) {
    my $name = $user->name;
    $user->__set( column => 'email_confirmed', value => 1 )
      unless $name eq 'RT_System';
}
print "updated table Users with success\n";
print "migrated with success!\n";

sub rename_columns {
    my ($table, %map) = (@_);

    my $handle = Jifty->handle;
    while ( my ($from, $to) = each %map ) {
        $handle->rename_column(
            table  => $table,
            column => $from,
            to     => $to,
        );
    }
}

sub drop_columns {
    my ($table, @columns) = @_;
    my $query = "ALTER TABLE $table ". join ', ', map "DROP COLUMN $_", @columns;
    return execute_query( $query );
}

sub execute_query {
    my ($query, @binds) = @_;

    print "Executing query: $query\n\n";

    my $sth = $dbh->prepare( $query ) or die "couldn't prepare $query\n\tError: ". $dbh->errstr;
    $sth->execute( @binds ) or die "couldn't execute $query\n\tError: ". $sth->errstr;
    return $sth;
}

=head1 NAME

rt-migrate-db-from-3.8

=head1 SYNOPSIS

    rt-migrate-db-from-3.8 --help
    rt-migrate-db-from-3.8 --upgrade

=head1 DESCRIPTION

before run, please backup your dbs
and we need to set up a basic rt4 db with the cmd:
$ jifty schema --setup --no-bootstrap

then run: ./sbin/migrate-db-from-rt3

options: 

help: print this usage
db-name-rt3: db name of rt3, default is 'rt3'

=cut
