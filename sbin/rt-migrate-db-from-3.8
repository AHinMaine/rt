#!/usr/bin/perl 
use strict;
use warnings;
use Getopt::Long;
use Carp;
use Text::Naming::Convention qw/renaming/;

use FindBin;
use lib "$FindBin::Bin/../lib";

use Jifty::Everything;
BEGIN {
    Jifty->new();
}

my %args;

confess "unknown option"
  unless GetOptions( \%args, 'db-type=s', 'db-name-rt3=s', 'db-name-rt4=s',
    'dba=s', 'help' );

my $USAGE = <<'END';
before run, please backup your dbs
and we need to set up a basic rt4 db with the cmd:
$ jifty schema --setup --no-bootstrap

then run: ./sbin/migrate-db-from-rt3

options: 

help: print this usage
db-type: db's type, mysql, Pg or SQLite
db-name-rt3: db name of rt3
db-name-rt4: db name of rt4
dba: database administrator
END

if ( $args{'help'} ) {
    print $USAGE;
    exit 0;
}

$args{'db-type'}     ||= 'mysql';
$args{'db-name-rt3'} ||= 'rt3';
$args{'db-name-rt4'} ||= 'rt4';

my %name_changes = (
    nick_name           => 'nickname',
    email_address       => 'email',
    principal_type      => 'type',
    immediate_parent_id => 'immediate_parent',
);

my @tables = qw/ACL Attachments  Attributes CachedGroupMembers CustomFieldValues
CustomFields GroupMembers Groups Links ObjectCustomFieldValues ObjectCustomFields    Principals  Queues ScripActions ScripConditions Scrips Templates Tickets
Transactions Users sessions/;

my $tables_need_change = 'ACL Principals Templates Scrips';
my $tables_no_change = 'Attachments  Attributes CachedGroupMembers CustomFieldValues CustomFields GroupMembers Groups Links ObjectCustomFieldValues ObjectCustomFields    Queues ScripActions ScripConditions Tickets Transactions Users sessions';

if ( $args{'db-type'} eq 'mysql' ) {
    $args{'dba'} ||= 'root';

    my $run_sql = sub {
        my $db  = shift;
        my @sql = @_;
        open my $fh, '|-', "mysql -u $args{'dba'} $db" or die $!;
        print $fh $_ for @sql;
        close $fh;
    };

    # make a tmp rt3 db, with to-be-dropped columns dropped
    my $tmp_rt3_db = "tmp_$args{'db-name-rt3'}_for_migration";
    $run_sql->( '',          "create database $tmp_rt3_db;\n" );

# copy tables need to change to $tmp_rt3_db
    system(
        "mysqldump -u $args{'dba'} $args{'db-name-rt3'} $tables_need_change |
      mysql -u $args{'dba'} $tmp_rt3_db"
    ) && die $!;

    # now we alert tables
    my @alter_sql = (
        'alter table ACL drop column DelegatedBy;',
        'alter table ACL drop column DelegatedFrom;',
        'alter table Principals drop column ObjectId;',
        'alter table Templates drop column Language;',
        'alter table Templates drop column TranslationOf;',
        'alter table Scrips drop column ConditionRules;',
        'alter table Scrips drop column ActionRules;'
    );
    $run_sql->( $tmp_rt3_db, @alter_sql );

    my $insert = sub {
        my $input_cmd = shift;

        open my $fh, '-|', $input_cmd or die $!;

        while (<$fh>) {
            next unless /^INSERT INTO/;
            my $insert = $_;

            # e.g. RT::Group -> RT::Model::Group
            $insert =~ s/'RT::(?!System|ScripAction)(\w+)\b/'RT::Model::$1/g;
            $insert =~ s/'Owner'/'owner'/g;
            $insert =~ s/'Requestor'/'requestor'/g;
            $insert =~ s/'Cc'/'cc'/g;
            $insert =~ s/'AdminCc'/'admin_cc'/g;
            $insert =~
s/(?<!INSERT INTO )`(\w+)`/'`' . ($name_changes{renaming( $1)} || renaming($1)) . '`'/ge;
            $run_sql->( $args{'db-name-rt4'}, $insert );
        }
    };

# insert unchanged(actually, no so changed) tables from origion db
    $insert->(
"mysqldump -u $args{'dba'} $args{'db-name-rt3'} --complete-insert --no-create-info $tables_no_change"
    );

# import changed tables form tmp db
    $insert->(
"mysqldump -u $args{'dba'} $tmp_rt3_db --complete-insert --no-create-info"
    );

    $run_sql->( '',                   "drop database $tmp_rt3_db\n" );

    # set up proper values for new added columns
    # Queue.status_schema: 'default' # this is done automatically by rt4
}

# need to add a row for the default status schema in Attributes and update
# part columns of that table
use RT::Model::AttributeCollection;
my $collection =
  RT::Model::AttributeCollection->new( current_user => RT->system_user );
$collection->unlimit;
while ( my $attr = $collection->next ) {
    my $desc = $attr->description;
    $desc =~ s/\[_(\d)\]/%$1/g; # [_1] => %1
    $attr->set_description($desc);

    my $content = $attr->content;

    next unless ref $content && ref $content eq 'HASH';
    for my $k ( keys %$content ) {
        my $v = $content->{$k};
        delete $content->{$k};
        $content->{ renaming $k} = $v;
    }
    my $format = $content->{'format'};
    if ( $format ) {
        # update for the name convention changes
        $format =~ s/__(?!WebPath)(\w+)__/'__' . renaming($1) . '__'/eg;
        $format =~ s/TITLE:Subject/TITLE:subject/g;
        $format =~ s/(,\s*|^\s*)(\w+)(?=\s*,|\s*$)/$1 . renaming($2)/eg;
        $content->{'format'} = $format;
    }
    $attr->set_content($content);
}

# add default status schema
use RT::Model::Attribute;
my $attribute = RT::Model::Attribute->new( current_user => RT->system_user );
my @results = $attribute->create(
    name        => 'StatusSchemas',
    object      => RT->system,
    description => 'all system status schemas',
    content     => {
        default => {
            initial     => ['new'],
            active      => [ 'open', 'stalled' ],
            inactive    => [ 'resolved', 'rejected', 'deleted' ],
            transitions => {
                new      => [qw(open resolved rejected deleted)],
                open     => [qw(stalled resolved rejected deleted)],
                stalled  => [qw(open)],
                resolved => [qw(open)],
                rejected => [qw(open)],
                deleted  => [qw(open)],
            },
            actions => {
                'new -> open'     => [ 'Open It', 'respond' ],
                'new -> resolved' => [ 'Resolve', 'comment' ],
                'new -> rejected' => [ 'Reject',  'respond' ],
                'new -> deleted'  => [ 'Delete',  '' ],

                'open -> stalled'  => [ 'Stall',   'comment' ],
                'open -> resolved' => [ 'Resolve', 'comment' ],
                'open -> rejected' => [ 'Reject',  'respond' ],
                'open -> deleted'  => [ 'Delete',  'hide' ],

                'stalled -> open'  => [ 'Open It',  '' ],
                'resolved -> open' => [ 'Re-open',  'comment' ],
                'rejected -> open' => [ 'Re-open',  'comment' ],
                'deleted -> open'  => [ 'Undelete', '' ],
            },
        }
    }
);


use RT::Model::UserCollection;
my $user_collection =
  RT::Model::UserCollection->new( current_user => RT->system_user );

while ( my $user = $user_collection->next ) {
    my $name = $user->name;
    $user->__set( column => 'email_confirmed', value => 1 )
      unless $name eq 'RT_System';
}

print "migrate succeeded!\n"

