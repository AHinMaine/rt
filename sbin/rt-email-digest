#!/usr/bin/env perl
# BEGIN BPS TAGGED BLOCK {{{
# 
# COPYRIGHT:
# 
# This software is Copyright (c) 1996-2008 Best Practical Solutions, LLC
#                                          <jesse@bestpractical.com>
# 
# (Except where explicitly superseded by other copyright notices)
# 
# 
# LICENSE:
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org.
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
# 
# 
# CONTRIBUTION SUBMISSION POLICY:
# 
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to Best Practical Solutions, LLC.)
# 
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# Request Tracker, to Best Practical Solutions, LLC, you confirm that
# you are the copyright holder for those contributions and you grant
# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
# 
# END BPS TAGGED BLOCK }}}
use warnings;
use strict;

use Date::Format qw( strftime );
use Getopt::Long;
use RT;
BEGIN { RT->init_jifty }

use RT::Interface::CLI qw( clean_env );
use RT::Interface::Email;

clean_env();
RT::load_config();
RT::init();

sub usage {
    my ($error) = @_;
    print _("Usage: ") . "$0 -m (daily|weekly) [--print] [--help]\n";
    print _(
        "%1 is a utility, meant to be run from cron, that dispatches all deferred RT notifications as a per-user digest.",
        $0
    ) . "\n";
    print "\n\t-m, --mode\t"
        . _("Specify whether this is a daily or weekly run.") . "\n";
    print "\t-p, --print\t"
        . _("Print the resulting digest messages to STDOUT; don't mail them. Do not mark them as sent")
        . "\n";
    print "\t-h, --help\t" . _("Print this message") . "\n";

    if ( $error eq 'help' ) {
        exit 0;
    } else {
        print _("Error") . ": " . _($error) . "\n";
        exit 1;
    }
}

my ( $frequency, $print, $help ) = ( '', '', '' );
GetOptions(
    'mode=s' => \$frequency,
    'print'  => \$print,
    'help'   => \$help,
);

usage('help') if $help;
usage("Mode argument must be 'daily' or 'weekly'")
    unless $frequency =~ /^(daily|weekly)$/;

run( $frequency, $print );

sub run {
    my $frequency = shift;
    my $print     = shift;

## Find all the tickets that have been modified within the time frame
##    described by $frequency.

    my ( $all_digest, $sent_transactions ) = find_transactions($frequency);

## Iterate through our huge hash constructing the digest message
##    for each user and sending it.

    foreach my $user ( keys %$all_digest ) {
        my ( $contents_list, $contents_body ) = build_digest_for_user( $user, $all_digest->{$user} );
        # Now we have a content head and a content body.  We can send a message.
        if ( send_digest( $user, $contents_list, $contents_body ) ) {
            print "Sent message to $user\n";
            mark_transactions_sent( $frequency, $user, values %{$sent_transactions->{$user}} ) unless ($print);
        } else {
            print "Failed to send message to $user\n";
        }
    }
}
exit 0;

# Subroutines.

sub send_digest {
    my ( $to, $index, $messages ) = @_;

    # Combine the index and the messages.

    my $body = "============== Tickets with activity in the last "
        . ( $frequency eq 'daily' ? "day" : "seven days" ) . "\n\n";

    $body .= $index;
    $body .= "\n\n============== Messages recorded in the last "
        . ( $frequency eq 'daily' ? "day" : "seven days" ) . "\n\n";
    $body .= $messages;

    # Load our template.  If we cannot load the template, abort
    # immediately rather than failing through many loops.
    my $digest_template = RT::Model::Template->new( current_user => RT->system_user );
    my ( $ret, $msg ) = $digest_template->load('Email Digest');
    unless ($ret) {
        print _("Failed to load template")
            . " 'Email Digest': "
            . $msg
            . ".  Cannot continue.\n";
        exit 1;
    }
    ( $ret, $msg ) = $digest_template->parse( Argument => $body );
    unless ($ret) {
        print _("Failed to parse template")
            . " 'Email Digest'.  Cannot continue.\n";
        exit 1;
    }

    # Set our sender and recipient.
    $digest_template->mime_obj->head->replace( 'From', RT->config->get('correspond_address') );
    $digest_template->mime_obj->head->replace( 'To',   $to );

    if ($print) {
        $digest_template->mime_obj->print;
        return 1;
    } else {
        return  RT::Interface::Email::send_email( entity      =>
                $digest_template->mime_obj)
    }
}

=item mark_transactions_sent( $frequency, $user, @txn_list );

Takes a frequency string (either 'daily' or 'weekly'), a user  and one or more
transaction objects as its arguments.  Marks the given deferred
notifications as sent.

=cut

sub mark_transactions_sent {
    my ( $freq, $user, @txns ) = @_;
    return unless $freq =~ /(daily|weekly)/;
    return unless @txns;
    foreach my $txn (@txns) {

        # Grab the attribute, mark the "sent" as true, and store the new
        # value.
        if ( my $attr = $txn->first_attribute('DeferredRecipients') ) {
            my $deferred = $attr->content;
            $deferred->{$freq}->{$user}->{'_sent'} = 1;
            $txn->set_attribute(
                name        => 'DeferredRecipients',
                description => 'Deferred recipients for this message',
                content     => $deferred,
            );
        }
    }
}

sub since_date {
    my $frequency = shift;

    # Specify a short time for digest overlap, in case we aren't starting
    # this process exactly on time.
    my $OVERLAP_HEDGE = 30;

    my $since_date = RT::DateTime->now;
    if ( $frequency eq 'daily' ) {
        $since_date->subtract(days => 1);
    } else {
        $since_date->subtract(days => 7);
    }

    $since_date->subtract(seconds => $OVERLAP_HEDGE);

    return $since_date;
}

sub find_transactions {
    my $frequency  = shift;
    my $since_date = since_date($frequency);

    my $txns = RT::Model::TransactionCollection->new( current_user => RT->system_user );

    # First limit to recent transactions.
    $txns->limit(
        column    => 'created',
        operator => '>',
        value    => $since_date->iso
    );

    # Next limit to ticket transactions.
    $txns->limit(
        column           => 'object_type',
        operator        => '=',
        value           => 'RT::Model::Ticket',
        entry_aggregator => 'AND'
    );
    my $all_digest        = {};
    my $sent_transactions = {};

    while ( my $txn = $txns->next ) {
        my $ticket = $txn->ticket;
        my $queue  = $ticket->queue->name;
        # Xxx todo - may clobber if two queues have the same name
        foreach my $user ( $txn->deferred_recipients($frequency) ) {
            $all_digest->{$user}->{$queue}->{$ticket->id}->{ $txn->id } = $txn->content_obj;
            $sent_transactions->{$user}->{ $txn->id } = $txn;
        }
    }

    return ( $all_digest, $sent_transactions );
}

sub build_digest_for_user {
    my $user        = shift;
    my $user_digest = shift;

    my $contents_list = '';    # Holds the digest index.
    my $contents_body = '';    # Holds the digest body.

    # Has the user been disabled since a message was deferred on his/her
    # behalf?
    my $user_obj = RT::Model::User->new( current_user => RT->system_user );
    $user_obj->load_by_email($user);
    if ( $user_obj->principal->disabled ) {
        print STDERR _("Skipping disabled user") . " $user\n";
        next;
    }

    print _("Message for user") . " $user:\n\n" if $print;
    foreach my $queue ( keys %$user_digest ) {
        $contents_list .= "Queue $queue:\n";
        $contents_body .= "Queue $queue:\n";
        foreach my $ticket ( sort keys %{ $user_digest->{$queue} } ) {
            my $tkt_txns   = $user_digest->{$queue}->{$ticket};
            my $ticket_obj = RT::Model::Ticket->new( current_user => RT->system_user );
            $ticket_obj->load($ticket);

            # Spit out the index entry for this ticket.
            my $ticket_title = sprintf(
                "#%d %s [%s]\t%s\n",
                $ticket, $ticket_obj->status, $ticket_obj->owner_obj->name,
                $ticket_obj->subject
            );
            $contents_list .= $ticket_title;

            # Spit out the messages for the transactions on this ticket.
            $contents_body .= "\n== $ticket_title\n";
            foreach my $txn ( sort keys %$tkt_txns ) {
                my $msg = $tkt_txns->{$txn};

                # $msg contains an RT::Model::Attachment with our outgoing
                # message.  Print a few headers for clarity's sake.
                $contents_body .= "From: " . $msg->get_header('From') . "\n";
                my $date = $msg->get_header('Date');
                unless ($date) {
                    my $txn_obj = RT::Model::Transaction->new( current_user => RT->system_user );
                    $txn_obj->load($txn);
                    $date = RT::DateTime->new_from_string($txn_obj->created)->rfc2822;
                }
                $contents_body .= "Date: $date\n\n";
                $contents_body .= $msg->content . "\n";
                $contents_body .= "-------\n";
            }    # foreach transaction
        }    # foreach ticket
    }    # foreach queue

    return ( $contents_list, $contents_body );

}
