%# BEGIN BPS TAGGED BLOCK 
%# 
%# COPYRIGHT:
%# 
%# This software is Copyright (c) 1996-2008 Best Practical Solutions, LLC
%#                                          <jesse@bestpractical.com>
%# 
%# (Except where explicitly superseded by other copyright notices)
%# 
%# 
%# LICENSE:
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
%# 
%# 
%# CONTRIBUTION SUBMISSION POLICY:
%# 
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%# 
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%# 
%# END BPS TAGGED BLOCK
%#
%# Data flow here:
%#   The page receives a Query from the previous page, and maybe arguments
%#   corresponding to actions.  (If it doesn't get a Query argument, it pulls
%#   one out of the session hash.  Also, it could be getting just a raw query from
%#   Build/Edit.html (Advanced).)
%#
%#   After doing some stuff with default arguments and saved searches, the parse_query
%#   function (which is similar to, but not the same as, _parser in RT/Tickets_Overlay_SQL)
%#   converts the Query into a RT::Interface::Web::QueryBuilder::Tree.  This mason file
%#   then adds stuff to or modifies the tree based on the actions that had been requested
%#   by clicking buttons.  It then calls GetQueryAndOptionList on the tree to generate
%#   the SQL query (which is saved as a hidden input) and the option list for the Clauses
%#   box in the top right corner.
%#
%#   Worthwhile refactoring: the tree manipulation code for the actions could use some cleaning
%#   up.  The node-adding code is different in the "add" actions from in parse_query, which leads
%#   to things like parse_query correctly not quoting numbers in numerical fields, while the "add"
%#   action does quote it (this breaks SQLite).
%#
<&| /_elements/wrapper, title => _("Query Builder") &>
<& /Ticket/Elements/Tabs, 
    current_tab => "Search/Build.html?".$query_string, 
    title => _("Query Builder"),
    %query,
	saved_search_id => $saved_search->{'id'},
&>

<form method="post" action="Build.html" name="build_query">
	<input type="hidden" class="hidden" name="saved_search_id" value="<% $saved_search->{'id'} %>" />
<input type="hidden" class="hidden" name="query" value="<% $query{'query'} %>" />
<input type="hidden" class="hidden" name="format" value="<% $query{'format'} %>" />




<div id="pick-criteria">
    <& Elements/PickCriteria, query => $query{'query'}, cfqueues => $queues &>
</div>
<& /Elements/Submit,  label => _('Add these terms'), name => 'add_clause'&>
<& /Elements/Submit, label => _('Add these terms and Search'), name => 'do_search'&>


<div id="editquery">
<& Elements/EditQuery,
    %ARGS,
    actions => \@actions,
    optionlist => $optionlist,
	description => $saved_search->{'description'},
    &>
</div>
<div id="editsearches">
    <& Elements/EditSearches, %$saved_search, current_search => \%query &>
</div>



<span id="display-options">

<& Elements/DisplayOptions,
    %ARGS, %query,
    available_columns => $available_columns,
    current_format    => $current_format,
&>

<& /Elements/Submit, label => _('Update format and Search'), name => 'do_search', id=>"formatbuttons"&>
</span>

</form>

</&>
<%INIT>
use RT::Interface::Web::QueryBuilder::Tree;

my $saved_search;
my %query = map { $_ => $ARGS{$_} } qw(query format order_by order rows_per_page);
my @actions = RT::Interface::Web::QueryBuilder->load_saved_search( \%ARGS, \%query, $saved_search );

if ($new_query) {

    # Wipe all data-carrying variables clear if we want a new
    # search, or we're deleting an old one..
    %query = ();
	$saved_search = { id => 'new'};

    # ..then wipe the sessionand the search results.
    Jifty->web->session->remove('CurrentSearchHash');
    Jifty->web->session->get('tickets')->clean_slate if defined Jifty->web->session->get('tickets');
}

{    # Attempt to load what we can from the session and preferences, set defaults

    my $current = Jifty->web->session->get('CurrentSearchHash');
    my $prefs   = Jifty->web->current_user->user_object->preferences("SearchDisplay") || {};
    my $default = { query => '', format => '', order_by => 'id', order => 'ASC', rows_per_page => 50 };

    for (qw(query format order_by order rows_per_page)) {
        $query{$_} = $current->{$_} unless defined $query{$_};
        $query{$_} = $prefs->{$_}   unless defined $query{$_};
        $query{$_} = $default->{$_} unless defined $query{$_};
    }

    for (qw(order order_by)) {
        if ( ref $query{$_} eq "ARRAY" ) {
            $query{$_} = join( '|', @{ $query{$_} } );
        }
    }

    $query{'format'} = RT::Interface::Web->scrub_html( $query{'format'} ) if ( $query{'format'} );
}

my $tree = RT::Interface::Web::QueryBuilder::Tree->new('AND');
push @actions, $tree->parse_sql( query => $query{query} );


my @options        = $tree->get_displayed_nodes;
my @current_values = grep defined, @options[@clauses];
my @new_values     = ();

foreach my $arg ( keys %ARGS ) {

    #  Try to find if we're adding a clause
    next
        unless $arg =~ m/^value_of_(\w+|'CF.{.*?}')$/
            && ( ref $ARGS{$arg} eq "ARRAY" ? grep $_ ne '', @{ $ARGS{$arg} } : $ARGS{$arg} ne '' );

    my $field = $1;

    #figure out if it's a grouping
    my $keyword = $ARGS{ $field . "_field" } || $field;

    my $op_name  = $field . "_op";
    my $op_value = 'value_of_' . $field;

    # we may have many keys/values to iterate over, because there
    # may be more than one CF with the same name.
    my @ops    = ref $ARGS{$op_value} ? @{ $ARGS{$op_name} }  : $ARGS{$op_name};
    my @values = ref $ARGS{$op_value} ? @{ $ARGS{$op_value} } : $ARGS{$op_value};

    Jifty->log->debug("Bad Parameters passed into Query Builder") unless @ops == @values;

    for ( my $i = 0; $i < @ops; $i++ ) {
        my ( $op, $value ) = ( $ops[$i], $values[$i] );
        next if !defined $value || $value eq '';

        if ( $value eq 'NULL' && $op =~ /=/ ) {
            if ( $op eq '=' ) {
                $op = "IS";
            } elsif ( $op eq '!=' ) {
                $op = "IS NOT";
            }
        } else {
            $value =~ s/'/\\'/g;
            $value = "'$value'" unless $value =~ /^\d+$/;
        }

        push @new_values, RT::Interface::Web::QueryBuilder::Tree->new(
            {   Key   => $keyword,
                Op    => $op,
                Value => $value
            }

        );
    }
}

push @actions, RT::Interface::Web::QueryBuilder->process_query( \%ARGS, $tree, \@current_values, \@new_values, );

#  Rebuild $Query based on the additions / movements

my $optionlist_arrayref;
( $query{'query'}, $optionlist_arrayref ) = $tree->get_query_and_option_list( \@current_values );

my $optionlist = join "\n", map {
          qq(<option value="$_->{INDEX}" $_->{SELECTED}>)
        . ( "&nbsp;" x ( 5 * $_->{DEPTH} ) )
        . Jifty->web->escape( $_->{TEXT})
        . qq(</option>) } @$optionlist_arrayref;

my $queues = $tree->get_referenced_queues;

#  Deal with format changes
my ( $available_columns, $current_format );

( $query{'format'}, $available_columns, $current_format ) = RT::Interface::Web::QueryBuilder->build_format_string(
    %ARGS,
    cfqueues => $queues,
    format   => $query{'format'},
);

# if we're asked to save the current search, save it
push @actions, RT::Interface::Web::QueryBuilder->save_search( \%ARGS, \%query, $saved_search );

#  Push the updates into the session so we don't loose 'em

Jifty->web->session->set( 'CurrentSearchHash',
    {   %query,
	search_id   => $saved_search->{'id'},
	object      => $saved_search->{'object'},
	description => $saved_search->{'description'},
    }
);

#  Show the results, if we were asked.

if ( $ARGS{'do_search'} ) {
    Jifty->web->redirect( Jifty->web->url . "Search/Results.html?" . 
                          RT::Interface::Web->format_query_params(%query) );

}

#  Build a query_string for the tabs

my $query_string = '';
if ($new_query) {
    $query_string = 'new_query=1';
} elsif ( $query{'query'} ) {
    $query_string = RT::Interface::Web->format_query_params(%query);
}

</%INIT>

<%ARGS>
$new_query => 0
@clauses => ()
</%ARGS>
