%# BEGIN BPS TAGGED BLOCK {{{
%# 
%# COPYRIGHT:
%#  
%# This software is Copyright (c) 1996-2007 Best Practical Solutions, LLC 
%#                                          <jesse@bestpractical.com>
%# 
%# (Except where explicitly superseded by other copyright notices)
%# 
%# 
%# LICENSE:
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/copyleft/gpl.html.
%# 
%# 
%# CONTRIBUTION SUBMISSION POLICY:
%# 
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%# 
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%# 
%# END BPS TAGGED BLOCK }}}
<%ARGS>
$format => RT->config->get('DefaultSearchResultFormat')
%cfqueues => ()
$face => undef
$size => undef
$link => undef
$title => undef

$add_col => undef
$remove_col => undef
$col_up => undef
$col_down => undef

$select_display_columns => undef
$current_display_columns => undef
</%ARGS>

<%init>
# This can't be in a <once> block, because otherwise we return the
# same \@fields every request, and keep tacking more CustomFields onto
# it -- and it grows per request.

# All the things we can display in the format string by default
my @fields = qw(
    id queue_name subject
    status extended_status update_status
    type owner_name requestors cc admin_cc created_by last_updated_by
    priority initial_priority final_priority
    time_worked time_left time_estimated
    starts      starts_relative
    started     started_relative
    created     created_relative
    last_updated last_updated_relative
    told        told_relative
    due         due_relative
    resolved    resolved_relative
    refers_to    referred_to_by
    depends_on   depended_on_by
    member_of    members
    parents     children
    NEWLINE
);

$m->callback( CallbackOnce => 1, Callbackname => 'SetFieldsOnce', Fields => \@fields );

my $CustomFields = RT::Model::CustomFieldCollection->new( current_user => Jifty->web->current_user);
foreach my $id (keys %cfqueues) {
    # Gotta load up the $queue object, since queues get stored by name now. my $id
    my $queue = RT::Model::Queue->new( current_user => Jifty->web->current_user );
    $queue->load($id);
    unless ($queue->id) {
        # XXX TODO: This ancient code dates from a former developer
        # we have no idea what it means or why cfqueues are so encoded.
        $id =~ s/^.'*(.*).'*$/$1/;
        $queue->load($id);
    }
    $CustomFields->limit_to_queue($queue->id);
}
$CustomFields->limit_to_global;

while ( my $CustomField = $CustomFields->next ) {
    push @fields, "custom_field.{" . $CustomField->name . "}";
}

$m->callback( Fields => \@fields, args_ref => \%ARGS );

my ( @seen);

$format ||= RT->config->get('DefaultSearchResultFormat');
my @format = split( /,\s*/, $format );
foreach my $field (@format) {
    my %column = ();
    $field =~ s/'(.*)'/$1/;
    my ( $prefix, $suffix );
    if ( $field =~ m/(.*)__(.*)__(.*)/ ) {
        $prefix = $1;
        $suffix = $3;
        $field  = $2;
    }
    $field = "<blank>" if !$field;
    $column{Prefix} = $prefix;
    $column{Suffix} = $suffix;
    $field =~ s/\s*(.*)\s*/$1/;
    $column{Column} = $field;
    push @seen, \%column;
}

if ( $remove_col ) {
    my $index  = $current_display_columns;
    my $column = $seen[$index];
    if ($index) {
        delete $seen[$index];
        my @temp = @seen;
        @seen = ();
        foreach my $element (@temp) {
            next unless $element;
            push @seen, $element;
        }
    }
}
elsif ( $add_col ) {
    if ( defined $select_display_columns ) {
        my $selected = $select_display_columns;
        my @columns;
        if (ref($selected) eq 'ARRAY') {
            @columns = @$selected;
        } else {
            push @columns, $selected;
        }
        foreach my $col (@columns) {
            my %column = ();
            $column{Column} = $col;

            if ( $face eq "Bold" ) {
                $column{Prefix} .= "<b>";
                $column{Suffix} .= "</b>";
            }
            if ( $face eq "Italic" ) {
                $column{Prefix} .= "<i>";
                $column{Suffix} .= "</i>";
            }
            if ($size) {
                $column{Prefix} .= "<" . $m->interp->apply_escapes( $size,  'h' ) . ">";
                $column{Suffix} .= "</" . $m->interp->apply_escapes( $size, 'h' ) . ">";
            }
            if ( $link eq "Display" ) {
                $column{Prefix} .= q{<a HREF="__WebPath__/Ticket/Display.html?id=__id__">};
                $column{Suffix} .= "</a>";
            }
            elsif ( $link eq "Take" ) {
                $column{Prefix} .= q{<a HREF="__WebPath__/Ticket/Display.html?Action=Take&id=__id__">};
                $column{Suffix} .= "</a>";
            }

            if ($title) {
                $column{Suffix} .= "/TITLE:" . $m->interp->apply_escapes( $title, 'h' );
            }
            push @seen, \%column;
        }
    }
}
elsif ( $col_up ) {
    my $index = $current_display_columns;
    if ( defined $index && ( $index - 1 ) >= 0 ) {
        my $column = $seen[$index];
        $seen[$index]       = $seen[ $index - 1 ];
        $seen[ $index - 1 ] = $column;
        $current_display_columns     = $index - 1;
    }
}
elsif ( $col_down ) {
    my $index = $current_display_columns;
    if ( defined $index && ( $index + 1 ) < scalar @seen ) {
        my $column = $seen[$index];
        $seen[$index]       = $seen[ $index + 1 ];
        $seen[ $index + 1 ] = $column;
        $current_display_columns     = $index + 1;
    }
}


my @format_string;
foreach my $field (@seen) {
    next unless $field;
    my $row = "'";
    $row .= $field->{'Prefix'} if defined $field->{'Prefix'};
    $row .= "__" . ($field->{'Column'} =~ m/\(/ ? $field->{'Column'} # func, don't escape
		    : $m->interp->apply_escapes( $field->{'Column'}, 'h' )) . "__"
      unless ( $field->{'Column'} eq "<blank>" );
    $row .= $field->{'Suffix'} if defined $field->{'Suffix'};
    $row .= "'";
    push( @format_string, $row );
}

$format = join(",\n", @format_string);


return($format, \@fields, \@seen);

</%init>
