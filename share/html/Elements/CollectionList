%# BEGIN BPS TAGGED BLOCK {{{
%# 
%# COPYRIGHT:
%# 
%# This software is Copyright (c) 1996-2008 Best Practical Solutions, LLC
%#                                          <jesse@bestpractical.com>
%# 
%# (Except where explicitly superseded by other copyright notices)
%# 
%# 
%# LICENSE:
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
%# 
%# 
%# CONTRIBUTION SUBMISSION POLICY:
%# 
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%# 
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%# 
%# END BPS TAGGED BLOCK }}}
<%INIT>
if (!$collection && $class eq 'RT::Model::TicketCollection') {
    $collection = RT::Model::TicketCollection->new;
    $collection->from_sql($query);
}
my $TotalFound = $collection->count_all();
return '' if !$TotalFound && !$show_empty;


if ( @order_by ) {
    if ( $order_by[0] =~ /\|/ ) {
        @order_by = split /\|/, $order_by[0];
        @order = split /\|/,$order[0];
    }
    $collection->order_by(
        map { { column => $order_by[$_], order => $order[$_] } }
        ( 0 .. $#order_by )
    );
}

$page = 1 unless $page && $page > 0; # workaround problems with Page = '' or undef
$page = 1 unless $page && $page > 0;    # workaround problems with $page = '' or undef

# $rows => 0 means unlimited. not a cool way to do this, so give it a huge 
# number
$collection->set_page_info(
    defined $rows
    ? ( per_page => $rows || 1_000_000_000 )
    : ( per_page => 25 ),
    current_page => $page
);

# display_format lets us use a "temporary" format for display, while 
# still using our original format for next/prev page links.
# bulk update uses this feature to add checkboxes

$display_format ||= $format;

# Scrub the html of the format string to remove any potential nasties.
$format = $m->comp('/Elements/ScrubHTML', content => $format);
$display_format = $m->comp('/Elements/ScrubHTML', content => $display_format);

my @format = $m->comp('/Elements/CollectionAsTable/ParseFormat', format => $display_format);

# Find the maximum number of items in any row, so we can pad the table.
my ($maxitems, $item) = (0, 0);
foreach my $col (@format) {
    $item++;
    if ( $col->{title} && ($col->{title} eq 'NEWLINE') ) {
        $item = 0;
    }
    else {
        $maxitems = $item if $item > $maxitems;
    }
}

$class ||= ref $collection;
$class =~ s/Collection$//;
$class =~ s/:/_/g;

$m->out('<table border="0" cellspacing="0" cellpadding="1"' . 
	' width="100%" class="' . 
	($collection->isa('RT::Model::TicketCollection') ? 'ticket-list' : 'collection') . '">');

if ( $show_header ) {
  $m->comp('/Elements/CollectionAsTable/Header',
	   %ARGS,
	   class        => $class,
	   format       => \@format,
	   format_string => $format,
	   order        => \@order,
	   order_by      => \@order_by,
	   rows         => $rows,
	   page         => $page,
	   allow_sorting => $allow_sorting, 
	   base_url      => $base_url,
	   generic_query_args => $generic_query_args,
	   maxitems     => $maxitems,
	   );
}

my ($i, $column_map) = (0, {});
while ( my $record = $collection->next ) {
    # Every ten rows, flush the buffer and put something on the page.
    $m->flush_buffer unless ++$i % 10;
    $m->comp('/Elements/CollectionAsTable/Row',
        i => $i,
        format => \@format,
        record => $record,
        maxitems => $maxitems,
        column_map => $column_map,
        class     => $class,
    );
}

$m->out('</table>');
if ( $rows && $show_navigation && $TotalFound > $rows ) {
  my $oddRows = ($TotalFound && $TotalFound % $rows == 0 )? 0 : 1;
  my $pages = int( $TotalFound / $rows ) + $oddRows;
  $pages = 1 if $pages < 1;


  my %query_args = map { $_ => $ARGS{$_} } @pass_arguments;
  $m->comp(
        '/Elements/CollectionListPaging',
        base_url     => $base_url,
        rows        => $rows,
        total_found  => $TotalFound,
        current_page => $page,
        pages       => $pages,
        url_params   => \%query_args
    );

}

</%INIT>
<%ARGS>
$class         => ''
$collection    => undef
$format        => undef
$display_format => undef
@order         => ()
@order_by       => ()
$generic_query_args => undef
$rows          => undef
$page          => 1
$title         => _('Ticket Search')
$base_url       => RT->config->get('web_path') . $m->request_comp->path .'?'
@pass_arguments => qw(query format rows page order order_by)
$allow_sorting   => 0
$show_navigation => 1
$show_header     => 1
$show_empty      => 0
$query => 0
</%ARGS>
