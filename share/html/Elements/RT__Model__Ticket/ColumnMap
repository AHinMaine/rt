%# BEGIN BPS TAGGED BLOCK {{{
%# 
%# COPYRIGHT:
%# 
%# This software is Copyright (c) 1996-2008 Best Practical Solutions, LLC
%#                                          <jesse@bestpractical.com>
%# 
%# (Except where explicitly superseded by other copyright notices)
%# 
%# 
%# LICENSE:
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
%# 
%# 
%# CONTRIBUTION SUBMISSION POLICY:
%# 
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%# 
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%# 
%# END BPS TAGGED BLOCK }}}
<%ARGS>
$name => undef
$attr => undef
</%ARGS>


<%ONCE>
my $COLUMN_MAP;

my $LinkCallback = sub  {
    my $method = shift;

    my $mode            = $RT::Model::Ticket::LINKTYPEMAP{$method}{mode};
    my $type            = $RT::Model::Ticket::LINKTYPEMAP{$method}{type};
    my $other_mode      = ($mode eq "target" ? "base" : "target");
    my $mode_uri        = $mode.'URI';
    my $local_type      = 'local_'.$mode;

    return sub  {
        map {
            \'<a href="',
            $_->$mode_uri->resolver->href,
            \'">',
            ( $_->$mode_uri->is_local ? $_->$local_type : $_->$mode ),
            \'</a><br />',
        } @{ $_[0]->links($other_mode,$type)->items_array_ref }
    }
};

$COLUMN_MAP = {
    queue => {
        attribute => 'queue',
        title     => 'Queue id', # loc
        value     => sub { return $_[0]->queue_id }
    },
    queue_name => {
        attribute => 'queue',
        title     => 'queue', # loc
        value     => sub  { return $_[0]->queue->name }
    },
    owner_name => {
        title     => 'Owner',
        attribute => 'Owner', # loc
        value     => sub  { return $_[0]->owner_obj->name }
    },
    status => {
        attribute => 'status',
        value     => sub  { return _($_[0]->status) }
    },
    subject => {
        title     => 'Subject', # loc
        attribute => 'subject',
        value => sub  { return $_[0]->subject || "(" . _('No subject') . ")" }
    },
    extended_status => {
        title     => 'Status', # loc
        attribute => 'Status',
        value     => sub  {
            my $Ticket = shift;

            if ( my $count = $Ticket->has_unresolved_dependencies ) {
                if (   $Ticket->has_unresolved_dependencies( type => 'approval' )
                    or $Ticket->has_unresolved_dependencies( type => 'code' ) )
                {
                    return \'<em>', _('(pending approval)'), \'</em>';
                }
                else {
                    return \'<em>', _('(pending %quant(%1,other ticket))',$count), \'</em>';
                }
            }
            else {
                return _( $Ticket->status );
            }

          }
    },
    priority => {
        attribute => 'priority',
        title     => 'Priority', # loc
        value     => sub  { return $_[0]->priority }
    },
    initial_priority => {
        attribute => 'initial_priority',
        title     => 'initial_priority', # loc
        name      => 'Initial Priority',
        value     => sub  { return $_[0]->initial_priority }
    },
    final_priority => {
        title     => 'final_priority', # loc
        attribute => 'final_priority',
        name      => 'Final Priority',
        value     => sub  { return $_[0]->final_priority }
    },
    effective_id => {
        title     => 'effective_id', # loc
        attribute => 'effective_id',
        value     => sub  { return $_[0]->effective_id }
    },
    type => {
        title     => 'type', # loc
        attribute => 'type',
        value     => sub  { return $_[0]->type }
    },
    time_worked => {
        attribute => 'time_worked',
        title => 'Time Worked', # loc
        value     => sub  { return $_[0]->time_worked }
    },
    time_left => {
        attribute => 'time_left',
        title     => 'Time Left', # loc
        value     => sub  { return $_[0]->time_left }
    },
    time_estimated => {
        attribute => 'time_estimated',
        title => 'Time Estimated', # loc
        value     => sub  { return $_[0]->time_estimated }
    },
    requestors => {
        title     => 'Requestors', # loc
        attribute => 'Requestor.email',
        value => sub  { return $_[0]->role_group("requestor")->member_emails_as_string }
    },
    cc => {
        title     => 'cc', # loc
        attribute => 'Cc.email',
        value => sub  { return $_[0]->role_group("cc")->member_emails_as_string }
    },
    admin_cc => {
        title       => 'admin_cc', # loc
        attribute => 'AdminCc.email',
        value => sub  { return $_[0]->role_group("admin_cc")->member_emails_as_string }
    },
    starts_relative => {
        title     => 'Starts', # loc
        attribute => 'starts',
        value     => sub  { return $_[0]->starts_obj->age }
    },
    started_relative => {
        title     => 'Started', # loc
        attribute => 'Started',
        value     => sub  { return $_[0]->started_obj->age }
    },
    told_relative => {
        title     => 'Told', # loc
        attribute => 'Told',
        value     => sub  { return $_[0]->told_obj->age }
    },
    due_relative => {
        title     => 'Due', # loc
        attribute => 'Due',
        value     => sub  { 
            my $date = $_[0]->due_obj;
            # Highlight the date if it was due in the past, and it's still active
            if ( $date && $date->unix > 0 && $date->diff < 0 && $_[0]->queue->status_schema->is_active($_[0]->status)) {
                return (\'<span class="overdue">' , $date->age , \'</span>');
            } else {
                return $date->age;
            }
        }
    },
    resolved_relative => {
        title     => 'Resolved', # loc
        attribute => 'resolved',
        value     => sub  { return $_[0]->resolved_obj->age }
    },
    starts => {
        title     => 'Starts', # loc
        attribute => 'starts',
        value     => sub  { return $_[0]->starts_obj->as_string }
    },
    started => {
        title     => 'Started', # loc
        attribute => 'Started',
        value     => sub  { return $_[0]->started_obj->as_string }
    },
    told => {
        title     => 'Told', # loc
        attribute => 'Told',
        value     => sub  { return $_[0]->told_obj->as_string }
    },
    due => {
        title     => 'Due', # loc
        attribute => 'Due',
        value     => sub  { return $_[0]->due_obj->as_string }
    },
    resolved => {
        title     => 'Resolved', # loc
        attribute => 'resolved',
        value     => sub  { return $_[0]->resolved_obj->as_string }
    },
    update_status => {
        title => 'New messages', # loc
        value => sub  {
            my $txn = $_[0]->seen_up_to or return $_[0]->_('No');
            return \('<a href="'. RT->config->get('WebPath') .'/Ticket/Display.html?id='
                . $_[0]->id .'#txn-'. $txn->id .'">'),
                $_[0]->_('New'), \'</a>';
        },
    },
    key_requestors => {
        title     => 'Requestors', # loc
        attribute => 'Requestor.email',
        value => sub  {
            my $t = shift;
            my @requestors = $t->role_group("requestor")->member_emails;
            for my $email (@requestors)
            {
                my %key = RT::Crypt::GnuPG::get_key_info($email);
                if (!defined $key{'info'}) {
                    $email .= _(" (no pubkey!)");
                }
                elsif ($key{'info'}{'trust_level'} == 0) {
                    $email .= _(" (untrusted!)");
                }
            }
            return join ', ', @requestors;
        }
    },
    key_owner_name => {
        title     => 'Owner', # loc
        attribute => 'Owner',
        value     => sub  {
            my $t = shift;
            my $name = $t->owner_obj->name;
            my %key = RT::Crypt::GnuPG::get_key_info($t->owner_obj->email);
            if (!defined $key{'info'}) {
                $name .= ' '. _("(no pubkey!)");
            }
            elsif ($key{'info'}{'trust_level'} == 0) {
                $name .= ' '. _("(untrusted!)");
            }

            return $name;
        }
    },

    # Everything from LINKTYPEMAP
    (map {
        $_ => { value => $LinkCallback->( $_ ) }
    } keys %RT::Model::Ticket::LINKTYPEMAP),

    '_CLASS' => {
        value => sub  { return $_[1] % 2 ? 'oddline' : 'evenline' }
    },
    '_CHECKBOX' => {
        attribute => 'checkbox',
        title => 'Update', # loc
        align     => 'right',
        value     => sub { return \('<input type="checkbox" class="checkbox" name="UpdateTicket'.$_[0]->id.'" value="1" checked="checked" />') }
    },

    custom_field => {
        attribute => undef,
        title     => sub  { return pop @_ },
        value     => sub  {
            # Display custom field contents, separated by newlines.
            # For Image custom fields we also show a thumbnail here.

            my $values = $_[0]->custom_field_values( $_[-1] );
            my @values = map {
                (
                    ($_->custom_field->type eq 'Image')
                        ? \($m->scomp( '/Elements/ShowCustomFieldImage', object => $_ ))
                        : $_->content
                ),
                \'<br />',
            } @{ $values->items_array_ref };
            pop @values; # Remove that last <br />
            return @values;
        },
    },
    bookmark => {
        title => ' ',
        value => sub {
            my $bookmark = $m->scomp( '/Ticket/Elements/Bookmark', id => $_[0]->id );
            # the CollectionAsTable/Row template replaces newlines with <br>
            $bookmark =~ s/\n//g;

            return \$bookmark;
        },
    },
};

$COLUMN_MAP->{'CF'} = $COLUMN_MAP->{'custom_field'};

# if no GPG support, then key_owner_name and key_requestors fall back to the regular
# versions
if (RT->config->get('GnuPG')->{'enable'}) {
    require RT::Crypt::GnuPG;
}
else {
    $COLUMN_MAP->{key_owner_name} = $COLUMN_MAP->{owner_name};
    $COLUMN_MAP->{key_requestors} = $COLUMN_MAP->{requestors};
}
</%ONCE>
<%init>
$m->callback( COLUMN_MAP => $COLUMN_MAP, callback_name => 'Once', callback_once => 1 );
# backward compatibility
$m->callback( COLUMN_MAP => $COLUMN_MAP, callback_name => 'ColumnMap' );
return get_column_map_entry( Map => $COLUMN_MAP, name => $name, Attribute => $attr );
</%init>
